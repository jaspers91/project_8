from selenium.webdriver import ActionChainsfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.common.exceptions import ElementNotInteractableException, TimeoutExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECclass UrbanRoutesPage:    FROM_LOCATOR = (By.ID, "from")    TO_LOCATOR = (By.ID, "to")    CUSTOM_OPTION_LOCATOR = (By.XPATH, "//div[normalize-space()='Custom']")    TAXI_OPTION = (By.XPATH, "//img[contains(@src,'taxi-active')]")    CALL_TAXI = (By.XPATH, "//button[normalize-space()='Call a taxi']")    SUPPORTIVE_CARD = (By.XPATH, "//div[contains(@class,'tcard')][.//div[@class='tcard-title' and normalize-space()='Supportive']]")    SELECTED_TARIFF_TITLE = (By.XPATH, "//div[contains (text(), 'Supportive')]")    HANDKERCHIEF = (By.XPATH, "//div[contains (text(), 'Blanket')]")    PHONE_BUTTON = (By.XPATH, "//div[@class='np-text' and normalize-space()='Phone number']/..")    PHONE_NUMBER = (By.ID, "phone")    PHONE_NEXT_BTN = (By.XPATH, "//button[normalize-space()='Next']")    SMS_CODE = (By.XPATH, "//input[@id='code']")    CONFIRM_BTN = (By.XPATH, "//button[normalize-space()='Confirm']")    CHECK_PHONE=(By.XPATH, "//div [@class= 'np-text']")    PAYMENT_METHOD = (By.XPATH, "//div[@class='pp-text' and normalize-space()='Payment method']")    ADD_CARD = (By.XPATH, "//div[contains(@class,'pp-title') and text()='Add card']")    CARD_NUMBER_INPUT = (By.ID, "number")    CARD_CODE_INPUT = (By.XPATH, "//div[@class='card-code-input']//input[@id='code' and contains(@class,'card-input')]")    LINK_BTN = (By.XPATH, "//button[contains(text(),'Link')]")    CLOSE_PAYMENT_MODAL = (By.XPATH, '//div[text()="Payment method"]/../button')    CHECK_CARD = (By.XPATH, "//div[@class='pp-title' and normalize-space()='Card']")    COMMENTS = (By.ID, "comment")    ORDER_REQUIREMENTS = (By.XPATH, "//div[@class='reqs-head' and normalize-space()='Order requirements']")    ORDER_SECTION_OPEN = (By.XPATH, "//div[contains(@class,'reqs open')]")  # container when expanded    BLANKET_SWITCH = (By.XPATH, "//div[normalize-space()='Blanket and handkerchiefs']/following-sibling::div//span[contains(@class,'slider')]")    ICE_CREAM = (By.XPATH, "//div[@class='r-counter-label' and text()='Ice cream']/following-sibling::div//div[contains(@class,'counter-plus')]")    ORDER = (By.XPATH, "//button[contains(@class,'smart-button')]")    PAYMENT_MODAL = (By.CSS_SELECTOR, ".payment-picker.open")  # modal container while open    # Replace your old locator with this one (scoped to the visible sheet)    SECTION_ACTIVE = (By.CSS_SELECTOR, "div.section.active")    OVERLAY = (By.CSS_SELECTOR, "div.overlay")    CAR_SEARCH = (By.XPATH, "//div[text()='Car search']")    # Constructor    def __init__(self, driver):        self.driver = driver        self.wait = WebDriverWait(driver, 10)    def enter_from_location(self, text):        self.wait.until(EC.element_to_be_clickable(self.FROM_LOCATOR)).clear()        self.driver.find_element(*self.FROM_LOCATOR).send_keys(text)    def enter_to_location(self, text):        self.wait.until(EC.element_to_be_clickable(self.TO_LOCATOR)).clear()        self.driver.find_element(*self.TO_LOCATOR).send_keys(text)    def enter_custom_option(self):        self.wait.until(EC.element_to_be_clickable(self.CUSTOM_OPTION_LOCATOR)).click()    def taxi_card_option(self):        self.wait.until(EC.element_to_be_clickable(self.TAXI_OPTION)).click()    def taxi_pick(self):        self.wait.until(EC.element_to_be_clickable(self.CALL_TAXI)).click()    def supportive_card_click(self):        # Click the “Supportive” tariff, then return the title that appears        self.wait.until(EC.element_to_be_clickable(self.SUPPORTIVE_CARD)).click()    def phone_number_click(self, text):        self.wait.until(EC.element_to_be_clickable(self.PHONE_NUMBER)).clear()        self.driver.find_element(*self.PHONE_NUMBER).send_keys(text)    def phone_number_next(self):        self.wait.until(EC.element_to_be_clickable(self.PHONE_NEXT_BTN)).click()    def confirm_phone_number(self):        self.wait.until(EC.element_to_be_clickable(self.CONFIRM_BTN)).click()    def check_phone(self):        return self.wait.until(EC.element_to_be_clickable(self.CHECK_PHONE)).text    def supportive_card_text(self):        return self.wait.until(EC.visibility_of_element_located(self.SELECTED_TARIFF_TITLE)).text    def add_card(self):        self.driver.find_element(*self.ADD_CARD).click()    def phone_button(self):        self.wait.until(EC.element_to_be_clickable(self.PHONE_BUTTON)).click()    def sms(self, code):        self.driver.find_element(*self.SMS_CODE).send_keys(code)    def payment_method(self):        self.driver.find_element(*self.PAYMENT_METHOD).click()    def card_number(self, number):        field = self.wait.until(EC.visibility_of_element_located(self.CARD_NUMBER_INPUT))        field.click()        field.send_keys(Keys.COMMAND, "a")  # use Keys.CONTROL on Windows        field.send_keys(Keys.DELETE)        field.send_keys(number)    def card_code(self, code: str):        field = self.wait.until(EC.visibility_of_element_located(self.CARD_CODE_INPUT))        field.click()        field.send_keys(Keys.COMMAND, "a")  # Keys.CONTROL on Windows        field.send_keys(Keys.DELETE)        field.send_keys(code)        field.send_keys(Keys.TAB)    def link_btn(self):        self.driver.find_element(*self.LINK_BTN).click()    def close_payment_modal(self):        self.driver.find_element(*self.CLOSE_PAYMENT_MODAL).click()    def check_card_text(self):        return self.wait.until(EC.visibility_of_element_located(self.CHECK_CARD)).text    def comments(self, text):        field = self.driver.find_element(*self.COMMENTS)        field.clear()        field.send_keys(text)        return field.get_attribute("value")    def open_order_requirements(self):        # scroll header into view and expand if collapsed        head = self.wait.until(EC.visibility_of_element_located(self.ORDER_REQUIREMENTS))        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", head)        # If section isn’t open, click to open        if not self.driver.find_elements(*self.ORDER_SECTION_OPEN):            head.click()            self.wait.until(EC.visibility_of_element_located(self.ORDER_SECTION_OPEN))    def is_blanket_on(self) -> bool:        slider = self.wait.until(EC.presence_of_element_located(self.BLANKET_SWITCH))        return 'checked' in (slider.get_attribute('class') or '')    def toggle_blanket(self):        # click the switch; works for both on/off        switch = self.wait.until(EC.element_to_be_clickable(self.BLANKET_SWITCH))        self.driver.execute_script("arguments[0].scrollIntoView({block:'center'});", switch)        switch.click()    def ensure_blanket_on(self):        if not self.is_blanket_on():            self.toggle_blanket()        # Small wait for class to update        # self.wait.until(lambda d: self.is_blanket_on()    def handkerchief_text(self):        return self.wait.until(EC.visibility_of_element_located(self.HANDKERCHIEF)).text    def ice_cream(self):        self.driver.find_element(*self.ICE_CREAM).click()        return "ice cream"    def order(self):        self.driver.find_element(*self.ORDER).click()    def car_search(self):        return self.driver.find_element(*self.CAR_SEARCH).text